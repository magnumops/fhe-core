# Architectural Decision Records (ADR) - Phase 3

## ADR-001: Синтезируемая Арифметика (Barrett Reduction)
*   **Дата:** Day 1
*   **Контекст:** Оригинальные модули `mod_mult` использовали операторы `%` и `/`, непригодные для синтеза в железо (ASIC/FPGA).
*   **Решение:** Внедрить алгоритм редукции Барретта.
*   **Детали:** Используется предвычисленная константа $\mu = \lfloor 2^{64} / Q \rfloor$. Умножение заменяется на серию сдвигов и вычитаний.
*   **Статус:** Внедрено.

## ADR-002: Выделенный Vector ALU
*   **Дата:** Day 2
*   **Контекст:** `ntt_arith_unit` был слишком специализирован под Butterfly-операции. Требовалась поддержка общих векторных операций (Add, Sub, Mult).
*   **Решение:** Выделить `vec_alu.v` как независимый комбинаторный модуль.
*   **Интерфейс:** Opcode (3 bit), OpA, OpB -> Result.
*   **Статус:** Внедрено.

## ADR-003: Динамические RNS Параметры
*   **Дата:** Day 3
*   **Контекст:** Эмулятор был жестко привязан к одному модулю Q (захардкоженные константы). RNS требует поддержки множества Q.
*   **Решение:** Удалить `localparam` из Verilog. Пробросить `input [63:0] q, mu, n_inv` через всю иерархию от Top-Level до листьев (`mod_mult`).
*   **Статус:** Внедрено.

## ADR-004: Command Processor и ISA
*   **Дата:** Day 4
*   **Контекст:** Управление эмулятором через прямые сигналы (`start`, `mode`) из C++ не масштабируется.
*   **Решение:** Внедрить архитектуру "Поток Команд".
    *   Создан модуль `command_processor.v`.
    *   Определена 64-битная ISA (Opcode 8b + Payload 56b).
    *   Связь C++ -> RTL через `CommandQueue` и DPI.
*   **Статус:** Внедрено.

## ADR-005: Многобанковая Память (Multi-Bank Memory)
*   **Дата:** Day 5
*   **Контекст:** Stateless-режим (загрузка-вычисление-выгрузка) неэффективен. Требуется хранение промежуточных результатов.
*   **Решение:**
    *   Внедрить внутреннюю память `mem [0:3][0:N-1]` (4 слота).
    *   Добавить команды `LOAD` (Host->Slot) и `STORE` (Slot->Host).
    *   Операции `NTT` и `ALU` теперь адресуют конкретный слот.
*   **Статус:** Внедрено.

## ADR-006: Гибридная Перестановка (Hybrid Bit-Reversal)
*   **Дата:** Day 7
*   **Контекст:** Аппаратный INTT требует данные в Bit-Reversed порядке, но аппаратный NTT выдает Natural.
*   **Решение:** В качестве временного решения (MVP) реализовать перестановку на стороне Host (C++/Python). SDK автоматически скачивает, переставляет и загружает данные обратно перед INTT.
*   **Статус:** Внедрено (Workaround).

## ADR-007: Динамическая Память Твиддлов (Dynamic Twiddles)
*   **Дата:** Day 8
*   **Контекст:** Использование статического ROM для Twiddle Factors приводило к ошибкам при смене модуля Q в RNS.
*   **Решение:**
    *   Заменить `twiddle_rom.v` на `twiddle_ram` (Writable).
    *   Ввести опкод `OPC_LOAD_W`.
    *   SDK вычисляет твиддлы для каждого Q и загружает их при `switch_context`.
*   **Статус:** Внедрено.

## ADR-008: SEAL Integration Bridge
*   **Дата:** Day 10
*   **Контекст:** Необходимость верификации эмулятора против эталонной реализации BFV. Написание полного BFV стека на Python трудоемко.
*   **Решение:**
    *   Обернуть библиотеку Microsoft SEAL (C++) через PyBind11.
    *   Реализовать методы экстракции RNS-компонент (`get_poly`) и инъекции результатов (`set_poly`).
    *   Использовать SEAL для генерации ключей, шифрования и финальной расшифровки.
*   **Статус:** Внедрено.

## ADR-009: Разделение Вычислений (Host-Side Accumulation)
*   **Дата:** Day 10
*   **Контекст:** Ограниченная память ускорителя (4 слота) не позволяет хранить все промежуточные векторы для сложных операций (например, тензорное произведение двух шифртекстов). Возникала ошибка `Out of Device Memory`.
*   **Решение:**
    *   Разбивать сложные операции на атомарные шаги (например, вычисление одного слагаемого).
    *   Скачивать промежуточные результаты (`D1_part1`, `D1_part2`) на Хост.
    *   Выполнять финальное сложение/сборку на Хосте.
*   **Статус:** Внедрено (Optimized for Memory).
