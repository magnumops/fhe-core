# Реестр Отвергнутых Гипотез и Тупиковых Ветвей

Этот файл содержит список решений, которые **не сработали**. Читать перед предложением "оптимизаций".

## 1. Архитектура и RTL
*   **Гипотеза:** Использовать оператор `%` для модулярной арифметики в Verilog.
    *   **Результат:** Провал. Не синтезируется эффективно.
    *   **Решение:** Barrett Reduction.
*   **Гипотеза:** Хранить Twiddle Factors в `twiddle_rom` (Hardcoded).
    *   **Результат:** Провал для RNS. При смене модуля $Q$ константы становятся неверными.
    *   **Решение:** `twiddle_ram` + загрузка через DMA.
*   **Гипотеза:** Выполнять сложные операции (A*B + C*D) полностью в железе без выгрузки.
    *   **Результат:** `Out of Device Memory`. Не хватает слотов (всего 4).
    *   **Решение:** Host-Side Accumulation (выгрузка промежуточных итогов).

## 2. Интеграция (C++/Verilator)
*   **Гипотеза:** Передавать `svBitVecVal*` в C++ для `output bit []` из Verilog.
    *   **Результат:** `Stack smashing detected`. ABI mismatch.
    *   **Решение:** Использовать `const svOpenArrayHandle`.
*   **Гипотеза:** Логирование через `$display` внутри `always @(state)`.
    *   **Результат:** Syntax Error (nested always) или Log Flooding (Docker зависает).
    *   **Решение:** Логирование на стороне C++ или heartbeat-логирование.

## 3. Python SDK & SEAL
*   **Гипотеза:** Инициализировать SEAL BFV с $K$ модулями для $K$ уровней данных.
    *   **Результат:** `RNS index out of bounds`. SEAL забирает последний модуль под "Special Prime".
    *   **Решение:** Передавать $K+1$ модулей.
*   **Гипотеза:** Цепочка `vec.ntt().intt()` работает прозрачно.
    *   **Результат:** Мусор на выходе. HW INTT требует bit-reversed вход, а HW NTT выдает natural.
    *   **Решение:** Гибридная перестановка (Auto-shuffle на хосте).
