# Architectural Decision Records (ADR)

Документ фиксирует ключевые архитектурные решения, принятые в ходе эволюции эмулятора Logos FHE.

---

# Phase 3: RNS & Arithmetic Foundation

## ADR-001: Синтезируемая Арифметика (Barrett Reduction)
*   **Контекст:** Оригинальные модули использовали операторы `%` и `/`, непригодные для синтеза.
*   **Решение:** Внедрить алгоритм редукции Барретта с предвычисленной константой $\mu$.
*   **Статус:** Внедрено.

## ADR-002: Выделенный Vector ALU
*   **Контекст:** `ntt_arith_unit` был слишком специализирован. Требовалась поддержка векторных Add/Sub/Mult.
*   **Решение:** Выделить `vec_alu.v` как независимый комбинаторный модуль.
*   **Статус:** Внедрено.

## ADR-003: Динамические RNS Параметры
*   **Контекст:** Жесткая привязка к одному модулю Q не позволяла реализовать RNS.
*   **Решение:** Пробросить `input [63:0] q, mu, n_inv` через всю иерархию модулей.
*   **Статус:** Внедрено (Позже эволюционировало в ADR-012).

## ADR-004: Command Processor и ISA
*   **Контекст:** Прямое управление пинами не масштабируется.
*   **Решение:** Внедрить 64-битную ISA (Opcode 8b + Payload 56b) и модуль `command_processor.v`.
*   **Статус:** Внедрено.

## ADR-005: Многобанковая Память (Multi-Bank Memory)
*   **Контекст:** Stateless-режим неэффективен.
*   **Решение:** Внедрить внутреннюю SRAM память `mem [0:3][0:N-1]` (4 слота) внутри ядра.
*   **Статус:** Внедрено.

---

# Phase 4: Observability

## ADR-006: VCD on Demand & TraceGuard
*   **Контекст:** Гигантские размеры VCD файлов тормозили CI.
*   **Решение:** Внедрить программное включение трассировки и Python-менеджер `TraceGuard` для записи только при ошибках.
*   **Статус:** Внедрено.

## ADR-007: Persistent Performance Counters
*   **Контекст:** Потеря метрик при сбросе (`rst`) ядра между этапами.
*   **Решение:** Вынести счетчики в отдельный `always` блок, игнорирующий мягкий сброс.
*   **Статус:** Внедрено.

---

# Phase 6: Dual Core Integration & System Stabilization

## ADR-008: Blocking Round-Robin Arbiter
*   **Дата:** Phase 6 Day 6
*   **Контекст:** При параллельной работе двух ядер с Арбитром фиксированного приоритета (DMA > C0 > C1) возникало "голодание" (Starvation) Core 1, приводящее к таймаутам. Также отсутствие очередей приводило к смешиванию ответов чтения.
*   **Решение:**
    1.  **Round-Robin:** Приоритет динамически переключается между C0 и C1.
    2.  **Blocking Mode:** Арбитр блокирует новые запросы на чтение (`req`), пока не придет подтверждение (`valid`) для текущего.
*   **Статус:** Внедрено. Критично для стабильности.

## ADR-009: Hybrid Linker Bridge (DPI Aliasing)
*   **Дата:** Phase 6 Day 3
*   **Контекст:** Конфликт имен DPI-функций. Legacy Verilog требовал `dpi_read_ram`, новый C++ драйвер использовал `py_read_ram`. Переписывание всего Verilog было рискованным.
*   **Решение:** Реализовать в `dpi_impl.cpp` гибридный слой: экспортировать символы с обоими префиксами, где одни вызывают другие (Forwarding).
*   **Статус:** Внедрено. Решило "Linker Hell".

## ADR-010: "Fire-and-Forget" Burst Write
*   **Дата:** Phase 6 Day 9
*   **Контекст:** Синхронное подтверждение записи (`valid` ack) в DPI-обертке вызывало "мигание" сигнала `gnt` в Арбитре, что ломало конвейер Burst-записи (данные записывались через одно слово или со сдвигом).
*   **Решение:**
    1.  Отключить генерацию `valid` для операций записи в `dpi_mem_wrapper.v`.
    2.  Считать запись мгновенной (так как это C++ вызов).
    3.  Перевести `wdata` в RTL на комбинаторную логику.
*   **Статус:** Внедрено. Обеспечило 100% целостность данных при выгрузке.

## ADR-011: Command Latching & Hold Time
*   **Дата:** Phase 6 Day 10
*   **Контекст:** Race Condition. Драйвер менял данные на шине команд слишком быстро. Ядро, получая сигнал `start`, успевало захватить уже *следующую* команду с шины.
*   **Решение:**
    1.  **Driver:** Ввести принудительный `Hold Cycle` (удержание данных 1 такт после снятия `valid`).
    2.  **RTL:** В `ntt_engine` защелкивать (`latch`) параметры команды (`opcode`, `addr`) во внутренние регистры в момент приема.
*   **Статус:** Внедрено. Устранило потерю команд при стресс-тестах.

## ADR-012: Config Load via DMA (RNS)
*   **Дата:** Phase 6 Day 8
*   **Контекст:** Необходимость передавать 192 бита конфигурации ($q, \mu, n\_inv$) через 64-битную шину команд.
*   **Решение:**
    1.  Хост пишет структуру конфигурации в RAM.
    2.  Введен опкод `OPC_CONFIG`. Ядро через DMA вычитывает 3 слова по указанному адресу и сохраняет их во внутренние регистры.
*   **Статус:** Внедрено. Заменило ADR-003.

## ADR-013: Memory Map Segmentation
*   **Дата:** Phase 6 Day 10
*   **Контекст:** При параллельной работе ядра перезаписывали данные друг друга из-за пересечения адресных пространств.
*   **Решение:** Утверждена карта памяти с шагом 64KB (`0x10000`) для изоляции векторов и твиддлов.
*   **Статус:** Внедрено в SDK и Тесты.
